<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>Project Documentation</title>
	<link href="https://fonts.googleapis.com/css?family=Press+Start+2P" rel="stylesheet">
	<style>
        h1{
            font-family: 'Press Start 2P', cursive;
        }
        
        h2{
            font-family: 'Press Start 2P', cursive;
        }
    </style>
</head>
<body>
    <h1 style="margin-bottom:2em;">Project 2 Documentation</h1>
    
    <h2 style="text-decoration:underline">How To Play</h2>
    <p>
        The arrow keys are used to move the player around. Walking over items on the ground picks them up. Walking into NPCs triggers conversation while walking into enemies triggers combat, which is done through message boxes in the browser. The goal of the game is to progress through this dungeon, defeat the evil dragon, rescue the captured wizard, and retrieve the Pendant of Power from the dragon’s lair.
    </p>
    <h2 style="text-decoration:underline">The Process</h2>
    <p>
        This project began with just an idea: what game should we make? We knew that it would need to be kept simple with a small scope, since we have a very limited time to create the project as well as limited knowledge of JavaScript as a programming language. Knowing this, we decided to create a simple, top-down adventure style game using a demo given to us as the base. This base gave us a solid starting point for the project. We had a player moving around a grid-like world, with a premade spritesheet and a foundation to build upon. Using this demo, we first added the inventory system. This was just a small area to the side of the game where it would display any objects the player picked up. We then actually implemented the pick up feature, first only making sure the object the player walked over was recognized, then adding this object to the inventory, and finally ensuring that the object was deleted from the map after being picked up. <br />
        From here, we chose to create more levels, allowing the player to move between room similar to games like The Legend of Zelda for the NES. After we had each room set up and navigation between them all working, we then began to work on a simplistic combat system where the player can walk into an enemy to attack it. In tandem with the combat system came a health system, to ensure that the player wasn’t only hitting enemies with no retaliation. A system for guards who block the player’s path unless a specific item was given to them was also implemented. We also added other NPCs to the world, including a fairy who can heal the player and a wizard whom the player is trying to save from the evil dragon. Next came the process of fleshing out these levels, adding structure to each room, populating the world with enemies and collectibles, and creating the goal that the player is trying to reach. After all this was completed, we finished the base of the game by adding in a game over state where, if the player is reduced to 0 hit points, they are slain and are sent to a game over screen. All development beyond this point was minor fixes and aesthetic changes, including a colored HP counter that turns red when the player is low on health, changing the sprites used by certain NPCs, and small bug fixes to ensure that the game runs smoothly.
    </p>
    <h2 style="text-decoration:underline">Meeting the Requirements</h2>
    <p>
        Most of the requirements were met naturally throughout the development of the game. The nature of the project as a game in general was our main goal for reaching the main requirement of being entertaining. While we could make a glorified tech demo and it would still be a game, per se, it wouldn’t be entertaining. At every point in our development, we ensured that the game always ran with no major errors. Every time we encountered some issue with our project, we quickly set out to fix it to ensure that the game always ran smoothly. While we did start with code given to us by our professor, we only used that code as a foundation for our project and used that to create something truly unique to our own vision. The sprites were all given to us with the initial code, but we chose which sprites to use in order to make sure the game actually looked like it made sense. <br />
	    The interface being clear was met fairly early in the process of creating this game. Our main interface is set to the side of the game area to ensure that no part of the game is covered by the interface and everything was clear and easy to read. Any major errors we encountered during our development were caught and accounted for early on so that the final product never ended up having any major issues. Small bugs exist due to the nature of the source code, such as the player character’s gradual movement causing text boxes to sometimes appear before the character is actually in the correct spot if the move button is held down, though it is not an issue that impairs the user’s enjoyment of the game in any way.
        <br />
	    As we finished the game, we utilized online validation services to ensure that the HTML and CSS validated. All of our styling is located in a single CSS file that is referenced in the main HTML file. Since this was a group project, each of us made sure to comment the code as we wrote it so that the other partner was never lost when they saw the new changes. The code is well-formatted and easy to understand, with comments placed in to help explain every aspect of the program, including big blocks of code or confusing parts of functions. 
    </p>
    <h2 style="text-decoration:underline">What We Each Did</h2>
    <h3>Rohit -</h3>
    <p>
	    For this project I primarily worked on the inventory system, treasure chest system, combat system, equipment system, and guard NPC. The inventory system used a table to store the item name, as well as the quantity of that item. Items could be picked up from the ground, gained from enemy drops, or retrieved when opening a chest. Chests could only be opened if the player had a key. The player would then be given an item picked at random from a list of treasure items. Weapons were added as a special type of item that always appeared at the top of the inventory to indicate they were “equipped”.  If the player were to try and pick up another weapon, the game would ask if they wanted to switch. Either choice would make the weapon drop to the ground (whichever weapon the player did not want). Weapons are an item drop of enemies. The combat system checked if the player had a weapon equipped. If they had not, they would not be able to engage the enemy. If the player engaged the enemy, by pressing the arrow key of the direction they were in, it would calculate a hit chance and compare it to the weapons hit stat and determine whether the attack would hit. It would then do damage based on its power stat. The same would be done for the enemy, unless the enemy was slayed before it could attack. When the enemy died, it would randomly generate a value to see if it would drop something, as well as the kind of item it would drop. Guard NPC’s were set having an item and a quantity value. Every time the player “engaged” the guard, they would ask for a preset item and preset quantity. Messages were generated based on whether the player did not have the item, whether they had enough of the item, whether they would like to give the item, and whether the player would decline to give the item. 
    </p>
    <h3>Allie -</h3>
    <p>
        Most of the work I did on this project was in regards to the multiple level system, including designing each room, implementing the system for changing rooms, and the final win screen. In order to create the level system, I first looked through our source code to understand how the level generation in general worked. After I had that understood, I set to work on creating functions that would make switching the level easy to write and reduce the amount of duplicated code we had. Each time the player went from one room to another, the game had to unload every object in the current room (except for the player), change the local level tracker to the new level reference and level number, set the list of current game objects to the list of total game objects in that room, reprint the new level to the screen, and move the player to an appropriate location as if they had walked through a passageway to the new area. Once the actual mechanic of switching levels was made, I created a door class which would have no image and be placed in the area that would trigger a level change. When the player collided with this specific door, the game would check which level it should switch to based on where the door that the player entered was, and then call my ResetLevel function to reset the level and then change it to the new one. When creating this system, I had to make sure that the objects for each level were completely unloaded and the new items reloaded to prevent the player from picking up items from one room while they were in another room. I also made sure that each item stayed gone after being picked up, even after the player left that room and then returned. After I had the first two rooms set up, I decided to add a small detail with the chest system we had. Initially, it was just the open chest sprite that the player would walk on with a key to open. I decided to make the chest appear closed when first encountered, and change to look open after being opened with the key. It was a pretty simple change, having the first chest be removed from the world and a new chest object with the open sprite being created in the exact same location. I then set out to design each level in its entirety, adding in monsters as hazards, loot to pick up, non-obstructive design elements, anything I could to make this game look fleshed out and well-designed. For one area, I decided to create a fairy NPC who would heal the player back up to full health. In order to reach her, the player would need to acquire some gold and give it to a guard in order to cross the bridge to the fairy. Interacting with her opens a text box asking the player if they want to be healed, this way the player can save the heal until they attempt to face the final boss. The design of this room was pretty simple, having just the fairy and a diamond locked away on an island behind two guards. The top room was pretty simple as well, being a most optional room where the player can fight more monsters and get more loot. For the second room the player encounters, I decided to add in a branching path. Since Rohit had added in the guard NPC, I thought it would be interesting to offer the choice of losing that gold to safely progress or to engage a series of monsters in order to continue on with the game. In the penultimate room, I added just the boss for the player to combat before finally reaching the goal. After the boss is defeated, the player can then enter the final room and talk to the rescued wizard. He doesn’t give the player anything, but he thanks the player for saving him and says to grab the Pendant of Power. I was initially stumped as to how I should implement a “you won” conclusion. At first I considered just having a message pop up to the screen and that was it, but instead I decided to teleport the player to a new room that says “The End” to conclude the game. I also made it so that, when the player is killed by an enemy, it tells them in a message box while they’re in combat.	
    </p>
    <h2 style="text-decoration:underline">Sources</h2>
    <p>
        The base source for this project began from the Adventure game demo that Sean Boyle sent to us. We utilized his code as the base for our project, including the art assets that we assume he created. We also used tutorials from W3Schools to help with understanding how to do certain things with JavaScript.
    </p>
</body>